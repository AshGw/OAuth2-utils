use sha2::{Digest, Sha256};
use crate::urlsafe::
{
    urlsafe_token,
    urlsafe_b64encode,
};

/// generates a random code verifier string of a specified size,
/// defaulting to 96 characters if no size is provided.
/// The `n` must be between `48` & `128`, view [#ref](https://datatracker.ietf.org/doc/html/rfc7636#section-4.1)
pub fn gen_code_verifier(n: Option<usize>) -> String {
    let size: usize = n.unwrap_or_else(|| 96);
    if size < 48 || size > 128 {
        panic!("Invalid size, the size must be between 48 and 128");
    }
    urlsafe_token(size) 
}

/// generates a code challenge by url-safe encoding the SHA256 hash of a given
/// code verifier.
/// 
/// Arguments:
/// 
/// * `code_verifier`: The `code_verifier` parameter is a string that represents a code verifier. It is
/// used in the OAuth 2.0 authorization code flow with PKCE (Proof Key for Code Exchange).
/// It is a random string that is generated by the client and used to create a code challenge
pub fn gen_code_challenge(code_verifier: &str) -> String {
    return urlsafe_b64encode(&Sha256::digest(code_verifier));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_gen_code_verifier_default_size() {
        let code_verifier: String = gen_code_verifier(None);
        assert_eq!(code_verifier.len(), 96);
    }

    #[test]
    fn test_gen_code_verifier_custom_size() {
        let custom_size: usize = 64;
        let code_verifier: String = gen_code_verifier(Some(custom_size));
        assert_eq!(code_verifier.len(), custom_size);
    }

    #[test]
    #[should_panic]
    fn test_gen_code_verifier_invalid_size() {
        gen_code_verifier(Some(32));
    }

    #[test]
    fn test_gen_code_challenge() {
        let code_verifier: &str = "quandale_dingle";
        let code_challenge: String = gen_code_challenge(code_verifier);
        assert_eq!(code_challenge.len(), 43);
    }
}
